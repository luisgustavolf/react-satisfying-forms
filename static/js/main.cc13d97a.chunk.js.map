{"version":3,"sources":["react-satisfying-forms/inspectors/inspector.tsx","react-satisfying-forms/inspectors/formInspector.tsx","react-satisfying-forms/contexts/formContext.tsx","react-satisfying-forms/validations/fieldValidatonManager.tsx","react-satisfying-forms/util/objectUtil.ts","react-satisfying-forms/validations/formValidationManager.tsx","react-satisfying-forms/form.tsx","react-satisfying-forms/formSubmit.tsx","react-satisfying-forms/formState.tsx","react-satisfying-forms/formValues.tsx","react-satisfying-forms/contexts/fieldGroupContext.tsx","react-satisfying-forms/validations/exampleValidators.ts","react-satisfying-forms/inspectors/fieldInspector.tsx","react-satisfying-forms/contextedField.tsx","react-satisfying-forms/field.tsx","react-satisfying-forms/fieldGroup.tsx","rsf-default-fields/inputField.tsx","samples/setFieldValues.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Inspector","props","color","borderColor","boderColor","now","Date","lastRender","getHours","getMinutes","getSeconds","getMilliseconds","className","style","padding","margin","border","borderRadius","marginBottom","marginTop","fontSize","display","background","boxShadow","header","children","backgroundColor","infos","fontStyle","FormInspector","inspect","form","state","formId","JSON","stringify","FormContext","React","createContext","FieldValidationManager","runningValidators","lastValdationResults","reportedErrors","this","value","validators","onError","onComplete","terminateAssyncValidators","Promise","all","executeValidators","map","validator","execution","executionResult","getValidatorResult","push","then","error","handleError","resolve","exection","validatorResult","undefined","promise","forEach","result","interrupCallback","cancel","flattenObject","rootNode","flattenObjectLoop","parents","flattenObj","key","hasOwnProperty","join","FormValidationManager","fieldsValidations","fieldValidations","flattendFieldValidations","registerFieldValidations","fieldname","validations","fieldValidator","getFieldValidations","validationManager","find","fd","Form","validationCounter","formValidationManager","registeredFields","formCount","toString","fieldsValues","initialValues","fieldsStatus","formStatus","submit","bind","handleSubmit","fieldName","prop","setState","prevState","pState","hasValidated","updateFormStatusAfterFieldStatusChange","newFormStatus","getFormStatusAfterFieldStatusChange","setFieldStatus","errors","isValidating","values","isStaless","setFieldValueFromFieldValuesProp","validateField","setFieldValueFromState","verifyIfParentIsNull","OPath","setFieldDirty","onChange","split","parent","index","path","slice","fieldValues","getFieldValue","removeChildStatus","prev","removeFieldStatus","updateFormStatus","includeChildren","Object","keys","indexOf","indexRegexp","test","initialIndex","parseInt","match","presProp","replace","nextProp","findIndex","f","splice","validationsAttrs","setFieldValidating","validate","setFieldErros","fieldsWithValidators","getFieldsWithValidations","fieldsThatHaventValidateYet","filter","getFieldStatus","fieldData","length","prevFormStatus","fieldProp","fieldValue","getFormStatus","dirty","hasErrors","status","fieldStatus","fieldsWValidations","fieldsValidated","log","getFilteredFieldValues","onSubmit","finalValues","onlyRegisteredFields","evt","keyCode","msg","console","warn","timerId","time","timeEnd","Provider","onKeyDownCapture","renderFields","Submit","State","Values","Consumer","formContextValues","FieldGroupContext","requiredValidator","FieldInspector","field","fullName","useDebouce","fUseDebounce","ContextedField","debouncedOnchange","innerFieldRef","isDebouncing","lastValidators","fInnerFieldRef","onClick","onBlur","onFocus","onChangeAfterDebouce","Debounce","updateValidatorsOnFormIfNecessary","validatorsAreTheSameAsLastOnes","getValidators","fForm","registerFieldValidators","fRequired","fExtraValidators","presentValidators","presentValidator","fullname","fOnFocus","setFieldTouched","fOnBlur","fOnClick","fCheckable","isChecked","target","checked","fCheckedValue","setFieldValue","persist","fOnChange","cb","valueOnFormState","registerField","verifyIfFieldValueCorrespondsToFormsValue","unregisterField","fieldStatusWithErrorHint","shouldDisplayErrors","touched","fieldBidings","ref","fInspect","fieldGroups","fFieldGroups","fName","Field","fieldGruopContextValues","parentChain","fProps","args","allParams","assign","newArgs","presetFProps","FieldGroup","getFieldGroupContextValue","parentFieldGroup","fieldGroup","name","formContext","parentFieldGroupContext","Component","InputField","fprops","fieldBindings","fielStatus","bidings","notFProps","SetFieldValues","formRef","current","setFieldsValues","group","subitem","subitem2","App","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.cc13d97a.chunk.js","sourcesContent":["import * as React from 'react'\n\nexport interface IInspectorProps {\n    header: React.ReactNode\n    infos: React.ReactNode\n    color?: string\n    boderColor?: string\n    children?: any\n}\n\nexport function Inspector(props: IInspectorProps) {\n    const color = props.color || \"#eee\";\n    const borderColor = props.boderColor || \"#ccc\";\n    const now = new Date();\n    const lastRender = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`\n\n    return  <div className='rsf-inspector' style={{padding: 10, margin: '10px 0px', border: `1px dotted ${borderColor}`, borderRadius: 5}}>\n        <div style={{marginBottom: 15, marginTop: 5, fontSize: 11}}>\n            <div style={{display: 'inline-block', background: color, padding: '5px 7px',  borderRadius: 5, boxShadow: '1px 1px 2px #333'}}>\n                {props.header}\n            </div>\n        </div>\n        {props.children}\n        <pre style={{backgroundColor: color, padding: 10, fontSize: 11, margin: '10px 0 0 0', borderRadius: 5}} >\n            {props.infos}\n            <div style={{fontSize: 9, marginTop: 10, fontStyle: 'oblique'}}>\n                last render: {lastRender}\n            </div>\n        </pre>  \n    </div>\n}","import * as React from 'react'\nimport { Form } from '../form';\nimport { Inspector } from './inspector';\n\nexport interface IFormInspector {\n    inspect: boolean\n    form: Form\n    children?: any\n}\n\nexport function FormInspector (props: IFormInspector) {\n    return !props.inspect ?\n        props.children :\n        <Inspector \n            header={`Form ${props.form.state.formId}`}\n            infos={JSON.stringify(props.form.state, null, 4)}\n        >\n            {props.children}\n        </Inspector>\n}","import React from \"react\";\nimport { Form } from \"../form\";\n\nexport interface FormContextValue {\n    form?: Form\n}\n\nexport const FormContext = React.createContext<FormContextValue>({})","import { FieldValidator, FieldValidatorResult, FieldValidatorAssyncResult, FieldValidatorSyncResult } from \"../interfaces/fieldValidator\";\n\nexport class FieldValidationManager {\n    private runningValidators: number\n    private lastValdationResults: FieldValidatorResult[]\n    private reportedErrors: string[]\n\n    constructor() {\n        this.lastValdationResults = [];\n        this.reportedErrors = [];\n        this.runningValidators = 0\n    }\n\n    getRunningValidators() {\n        return this.runningValidators;\n    }\n\n    async validate(value: any, validators: FieldValidator[], onError: (errors: string[]) => void, onComplete: (errors?: string[]) => void) {\n        this.terminateAssyncValidators()\n        \n        this.runningValidators++\n        await Promise.all(this.executeValidators(value, validators, onError));\n        this.runningValidators--\n        onComplete(this.reportedErrors);\n    }\n    \n    private executeValidators(value: any, validators: FieldValidator[], onError: (error: string[]) => void) {\n        this.reportedErrors = []\n        this.lastValdationResults = [];\n\n        return validators.map((validator) => {\n            const execution = validator(value);\n            const executionResult = this.getValidatorResult(execution);\n            this.lastValdationResults.push(execution);\n\n            if (executionResult instanceof Promise) {\n                return executionResult.then((error) => { this.handleError(error, onError) })\n            } else {\n                this.handleError(executionResult, onError)\n                return Promise.resolve()\n            }\n        })\n    }\n\n    private handleError(exection: FieldValidatorSyncResult, onError: (error: string[]) => void) {\n        if (exection)\n            this.reportedErrors.push(exection)\n        \n        onError(this.reportedErrors);\n    }\n\n    private getValidatorResult(validatorResult: FieldValidatorResult) {\n        if (validatorResult === undefined)\n            return undefined\n        \n        const resultPromise = (validatorResult as FieldValidatorAssyncResult).promise\n        return resultPromise || validatorResult;\n    }\n\n    private terminateAssyncValidators() {\n        this.lastValdationResults.forEach((result) => {\n            if (result) {\n                const interrupCallback = (result as FieldValidatorAssyncResult).cancel\n                interrupCallback && interrupCallback();\n            }\n        })\n    }\n}","export function flattenObject(rootNode: {[prop: string]: any}) {\n    return flattenObjectLoop({...rootNode})\n}\n\nfunction flattenObjectLoop(rootNode: {[prop: string]: any}, parents: string[] = []) {\n    let flattenObj: { [name: string]: any } = {}\n    for (const key in rootNode) {\n        if (rootNode.hasOwnProperty(key)) {\n            if (typeof rootNode[key] == \"object\")\n                flattenObj = { ...flattenObj, ...flattenObjectLoop(rootNode[key], [...parents, key])}\n            else {\n                flattenObj[[...parents,key].join('.')] = rootNode[key] \n            }\n        }\n    }\n\n    return flattenObj;\n}","import { FieldValidationManager } from \"./fieldValidatonManager\";\nimport { FieldValidations } from '../interfaces/fieldValidations';\nimport { flattenObject } from '../util/objectUtil';\nimport { FieldValidation } from \"../interfaces/fieldValidation\";\n\nexport interface FieldValidationWithValidationMng<TData>  {\n    fieldname: string\n    validations: FieldValidation<TData> \n    validationManager: FieldValidationManager\n}\n\nexport class FormValidationManager<TData> {\n\n    fieldsValidations: FieldValidationWithValidationMng<TData>[] = []\n    \n    registerFieldsValidations(fieldValidations: FieldValidations<TData>) {\n        const flattendFieldValidations = flattenObject(fieldValidations)\n        for (const key in flattendFieldValidations) {\n            if (flattendFieldValidations.hasOwnProperty(key)) {\n                this.registerFieldValidations(key, flattendFieldValidations[key])\n            }\n        }\n    }\n\n    registerFieldValidations(fieldname: string, validations: FieldValidation<TData>) {\n        const fieldValidator = this.getFieldValidations(fieldname)\n        \n        if (fieldValidator)\n            fieldValidator.validations = validations\n        else\n            this.fieldsValidations.push({\n                fieldname,\n                validations,\n                validationManager: new FieldValidationManager()\n            })\n    }\n\n    getFieldValidations(fieldname: string) {\n        return this.fieldsValidations.find((fd) => fd.fieldname === fieldname)\n    }\n\n    getFieldsWithValidations() {\n        return this.fieldsValidations.map((validations) => validations.fieldname)\n    }\n}","import * as React from 'react'\nimport * as OPath from 'object-path';\nimport { FieldStatusWithValue } from './interfaces/fieldStatusWithValue';\nimport { FieldStatus } from './interfaces/fieldStatus';\nimport { FormInspector } from './inspectors/formInspector';\nimport { IFormFieldValues as FormFieldValues } from './interfaces/iFormFieldValues';\nimport { FormStatus } from './interfaces/formStatus';\nimport { FormContext } from './contexts/formContext';\nimport { FieldValidations } from './interfaces/fieldValidations';\nimport { FieldValidator } from './interfaces/fieldValidator';\nimport { FormValidationManager } from './validations/formValidationManager';\nimport { FormSubmit, FormSubmitProps } from './formSubmit';\nimport { FormState, FormStateProps } from './formState';\nimport { FormFieldsValues, FormFieldsValuesProps } from './formValues';\n\nexport interface FormProps<TData> {\n    inspect?: boolean\n    onlyRegisteredFields?:boolean\n    initialValues?: TData\n    fieldsValues?: TData\n    fieldsValidations?: FieldValidations<TData>\n    onSubmit?: (fieldsValues: TData) => void\n    onChange?: (fieldsValues: TData) => void\n    children?: React.ReactNode\n}\n\nexport interface FormState<TData> extends FormFieldValues<TData> {\n    formId: string\n    fieldsStatus: { \n        [fieldName: string]: FieldStatus \n    }\n    formStatus: FormStatus\n}\n\nexport class Form<TData extends Object = {}, TProps extends Object = {}, TState extends Object = {}> \n        extends React.Component<FormProps<TData> & TProps, FormState<TData> & TState> {\n    \n    static formCount: number = 0\n    static Submit: (props: FormSubmitProps) => JSX.Element\n    static State: <TData>(props: FormStateProps<TData>) => JSX.Element\n    static Values: <TData>(props: FormFieldsValuesProps<TData>) => JSX.Element\n    \n    private validationCounter: number = 0\n    private formValidationManager: FormValidationManager<any>\n\n    public registeredFields: string[] = []\n\n    state: Readonly<FormState<TData> & TState> = {\n        ...this.state,\n        formId: (Form.formCount++).toString(),\n        fieldsValues: this.props.initialValues || {} as TData,\n        fieldsStatus: {},\n        formStatus: {},\n    }\n\n    ///////////////////////////////////////////////////////////\n    // Tree search & rebuild\n\n    constructor(props: any) {\n        super(props);\n        this.submit = this.submit.bind(this);\n        \n        this.formValidationManager = new FormValidationManager<TData>()\n        this.handleSubmit = this.handleSubmit.bind(this);\n    }\n\n    ///////////////////////////////////////////////////////////\n    // Flags\n\n    get isStaless() {\n        return !!(this.props.fieldsValues)\n    }\n\n    get fieldValues() {\n        return this.isStaless ? this.props.fieldsValues! : this.state.fieldsValues\n    }\n\n    ///////////////////////////////////////////////////////////\n    // Props manipulation\n\n    private setFieldStatus(fieldName: string, prop: string, value: any) {\n        if (this.state.fieldsStatus[fieldName] && this.state.fieldsStatus[fieldName][prop] === value)\n            return\n\n        this.setState((prevState) => { \n            //prevState.fieldsStatus[fieldName] = { ...prevState.fieldsStatus[fieldName], [prop]: value }\n            const pState = {\n                ...prevState,\n                fieldsStatus: { \n                    ...prevState.fieldsStatus, \n                    [fieldName]: {\n                        ...prevState.fieldsStatus[fieldName], \n                        [prop]: value\n                    }\n                }\n            }\n            \n            if(prop === 'isValidating' && !value)\n                pState.fieldsStatus[fieldName].hasValidated = true\n\n            return { \n                fieldsStatus:  { ...pState.fieldsStatus }\n            }\n        }, () => { \n            this.updateFormStatusAfterFieldStatusChange(prop, value)\n        })\n    }\n\n    updateFormStatusAfterFieldStatusChange(prop: string, value: any) {\n        this.setState((prevState) => {\n            const newFormStatus = this.getFormStatusAfterFieldStatusChange({...prevState.formStatus}, prop, value)\n            return { formStatus: { ...prevState.formStatus, ...newFormStatus } }\n        })\n    }\n\n    setFieldTouched(fieldName: string) {\n        this.setFieldStatus(fieldName, 'touched', true)\n    }\n\n    setFieldDirty(fieldName: string) {\n        this.setFieldStatus(fieldName, 'dirty', true)\n    }\n\n    setFieldErros(fieldName: string, errors: (string | undefined)[]) {\n        this.setFieldStatus(fieldName, 'errors', errors)\n    }\n\n    setFieldValidating(fieldName: string, isValidating: boolean) {\n        this.setFieldStatus(fieldName, 'isValidating', isValidating)\n    }\n\n    setFieldsValues(values: TData) {\n        this.setState({\n            ...this.state,\n            fieldsValues: values,\n            fieldsStatus: {},\n            formStatus: {}\n        })\n    }\n\n    async setFieldValue(fieldName: string, value: any) {\n        if (this.isStaless) { \n            this.setFieldValueFromFieldValuesProp(fieldName, value) \n            this.validateField(fieldName)\n            return Promise.resolve()\n        } else {\n            return this.setFieldValueFromState(fieldName, value).then(() => { \n                this.validateField(fieldName)\n                return Promise.resolve()\n            });\n        }\n    }\n\n    private async setFieldValueFromState(fieldName: string, value: any) {\n        return new Promise((resolve) => {\n            this.setState((prevState) => { \n                this.verifyIfParentIsNull(prevState, fieldName)\n                OPath.set(prevState.fieldsValues, fieldName, value)\n                return { fieldsValues:  {...prevState.fieldsValues }}\n            }, () => {\n                this.setFieldDirty(fieldName);\n                \n                if(this.props.onChange)\n                    this.props.onChange({...this.state.fieldsValues});\n                \n                resolve();\n            })\n        })\n    }\n    \n    // Prevent child values to be seted, from a null parent,\n    // causing errors on typing new valuess\n    private verifyIfParentIsNull(state: (FormState<TData> & TState), fieldName: string) {\n        const parents = fieldName.split('.');\n        parents.forEach((parent, index) => {\n            const pathParts = parents.slice(0, index);\n            const path = pathParts.join('.');\n\n            if (OPath.get(state.fieldsValues, path) === null) {\n                OPath.set(state.fieldsValues, path, {})\n            }\n        })\n    }\n\n    private async setFieldValueFromFieldValuesProp(fieldName: string, value: any) {\n        let fieldValues = {...this.props.fieldsValues}\n        OPath.set(fieldValues, fieldName, value)\n        this.setFieldDirty(fieldName);\n                \n        if(this.props.onChange)\n            this.props.onChange(fieldValues as TData);\n\n        return Promise.resolve()\n    }\n\n    getFieldValue(fieldName: string): any {\n        return OPath.get(this.fieldValues, fieldName);\n    }\n\n    getFieldStatus(fieldName: string): FieldStatusWithValue {\n        return {\n            ...this.state.fieldsStatus[fieldName],\n            value: this.getFieldValue(fieldName)\n        }\n    }\n\n    async removeField(fieldName: string, removeChildStatus: boolean = true) {\n        if (!OPath.has(this.state.fieldsValues, fieldName))\n            return\n        \n        return new Promise((resolve) => { \n            this.setState((prev) => {\n                OPath.del(prev.fieldsValues, fieldName)\n                this.removeFieldStatus(prev, fieldName, removeChildStatus)\n                return { ...prev }\n            }, () => { \n                this.updateFormStatus().then(() => resolve())\n            })\n        })\n    }\n\n    private removeFieldStatus(state: FormState<TData>, fieldName: string, includeChildren: boolean = true) {\n        Object.keys(state.fieldsStatus).forEach((key) => {\n            if (key === fieldName || (includeChildren && key.indexOf(`${fieldName}.`) > -1))\n                delete state.fieldsStatus[key]\n        })\n        \n        const indexRegexp = /\\.(\\d{1,})$/\n        \n        // Verify if its a array prop\n        if (indexRegexp.test(fieldName)) {\n            let initialIndex = parseInt(fieldName.match(indexRegexp)![1])\n            \n            while(true) {\n                const presProp = fieldName.replace(indexRegexp, `.${initialIndex}`);\n                const nextProp = fieldName.replace(indexRegexp, `.${initialIndex + 1}`);\n                \n                if (!OPath.has(state, nextProp))\n                    break\n                \n                OPath.set(state, presProp, OPath.get(state, nextProp))\n                initialIndex++\n            }\n        }\n\n        return state\n    }\n\n    /////////////////////////////////////////////////////////\n    // Fieldregistration\n\n    registerField(fieldName: string) {\n        this.registeredFields.push(fieldName);\n    }\n\n    unregisterField(fieldName: string) {\n        const index = this.registeredFields.findIndex((f) => fieldName);\n        if (index > -1) {\n            this.registeredFields.splice(index, 0);\n        }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Validations\n\n    registerFieldValidators(fieldname: string, validators: FieldValidator[]) {\n        this.formValidationManager.registerFieldValidations(fieldname, (fieldValues) => validators)\n    }\n    \n    async validateField(fieldName: string) {\n        const validationsAttrs = this.formValidationManager.getFieldValidations(fieldName);\n        \n        if (validationsAttrs === undefined)\n            return \n        \n        this.setFieldValidating(fieldName, true);\n        const validations = validationsAttrs.validations(this.fieldValues)\n        return new Promise((resolve) => {\n            validationsAttrs.validationManager.validate(\n                this.getFieldValue(fieldName), \n                validations, \n                (errors) => { this.setFieldErros(fieldName, errors); },\n                (errors) => { this.setFieldValidating(fieldName, false); resolve(errors) })\n        })\n    }\n\n    async validate() {\n        const fieldsWithValidators = this.formValidationManager.getFieldsWithValidations()\n        \n        if (!fieldsWithValidators)\n            return\n        \n        const fieldsThatHaventValidateYet = fieldsWithValidators.filter((fieldname) => {\n            const fieldStatus = this.getFieldStatus(fieldname);\n            return !fieldStatus.hasValidated\n        })\n\n        const validators = fieldsThatHaventValidateYet.map((fieldname) => this.validateField(fieldname))\n        await Promise.all(validators);\n        return fieldsWithValidators.filter((fieldname) => { \n            const fieldData = this.getFieldStatus(fieldname)\n            return fieldData.errors && fieldData.errors.length\n        }).map(fieldname => ({ \n            fieldname, \n            errors: this.getFieldStatus(fieldname).errors \n        }))\n    }\n\n    /////////////////////////////////////////////////////////\n    // Form Status\n\n    getFormStatusAfterFieldStatusChange(prevFormStatus: FormStatus, fieldProp: any, fieldValue: any) {\n        const formStatus = this.getFormStatus();\n        let newFormStatus:FormStatus = {...prevFormStatus}\n            \n        if (fieldProp === 'dirty') {\n            newFormStatus.dirty = true\n        } else if (fieldProp === 'isValidating') {\n            fieldValue === true ? this.validationCounter++ : this.validationCounter--\n        }\n        \n        newFormStatus.isValidating = this.validationCounter > 0\n        newFormStatus.hasValidated = formStatus.hasValidated\n        newFormStatus.hasErrors = formStatus.hasErrors\n\n        return newFormStatus\n    }\n\n    async updateFormStatus() {\n        const formStatus = this.getFormStatus();\n        return new Promise(resolve => {\n            this.setState((prev) => ({\n                formStatus: {...prev.formStatus, ...formStatus}\n            }), () => resolve())\n        })\n    }\n\n    getFormStatus() {\n        let status:FormStatus = {}\n        status.hasValidated = true;\n\n        for (const key in this.state.fieldsStatus) {\n            if (this.state.fieldsStatus.hasOwnProperty(key)) {\n                const fieldStatus = this.state.fieldsStatus[key];\n                status.isValidating = status.isValidating || fieldStatus.isValidating\n                status.dirty = status.dirty || fieldStatus.dirty\n                status.hasErrors = status.hasErrors || (fieldStatus.errors && fieldStatus.errors.length ? true : false)\n            } \n        }\n\n        const fieldsWValidations = this.formValidationManager.getFieldsWithValidations()\n        const fieldsValidated = fieldsWValidations.filter(fieldname => {\n            return this.getFieldStatus(fieldname).hasValidated === true\n        })\n\n        status.hasValidated = fieldsValidated.length === fieldsWValidations.length\n\n        return status\n    }\n\n    async submit() {\n        this.log('submiting...')\n        if (this.state.formStatus.isValidating) {\n            this.log('form is validating...')\n            return false\n        } else if (!this.state.formStatus.hasValidated) {\n            this.log('form needs validation. Validating...')\n            const result = await this.validate();\n            if (result && result.length > 0) {\n                this.log('form have some errors...')\n                return false;\n            }\n        } else if (this.state.formStatus.hasErrors) {\n            this.log('form have some errors...')\n            return false\n        } \n        \n        const values = this.getFilteredFieldValues();\n\n        if(this.props.onSubmit) \n            this.props.onSubmit(values)\n\n        return values;\n    }\n\n    getFilteredFieldValues() {\n        const finalValues = { } as TData;\n        \n        if (this.props.onlyRegisteredFields === false)\n            return {...this.state.fieldsValues};\n\n        this.registeredFields.forEach((fieldName) => {\n            if (OPath.has(this.state.fieldsValues, fieldName)) {\n                OPath.set(finalValues, fieldName, OPath.get(this.state.fieldsValues, fieldName));\n            }\n        })\n\n        return finalValues            \n    }\n\n    /////////////////////////////////////////////////////////\n    // Handlers\n\n    handleSubmit(evt: React.KeyboardEvent<HTMLDivElement>) {\n        if (evt.keyCode === 13) {\n            this.submit();\n        }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Render events\n\n    // componentDidUpdate() {\n    //     this.logTimeEnd(`Form#${this.state.formId} update`)\n    // }\n\n    // componentDidMount() {\n    //     this.logTimeEnd(`Form#${this.state.formId} mount`)\n    // }\n\n    /////////////////////////////////////////////////////////\n    // Render methods\n\n    log(msg: string) {\n        if (this.props.inspect)\n            console.log(msg)\n    }\n\n    warn(msg: string) {\n        if (this.props.inspect)\n            console.warn(msg)\n    }\n\n    logTime(timerId: string) {\n        if (this.props.inspect)\n            console.time(timerId)\n    }\n\n    logTimeEnd(timerId: string) {\n        if (this.props.inspect)\n            console.timeEnd(timerId)\n    }\n\n    /////////////////////////////////////////////////////////\n    // Render methods\n\n    /**\n     * When using inheritance, use this method as a replacement\n     * for the defaults 'render'.\n     */\n    renderFields():React.ReactNode {\n        return <React.Fragment />\n    }\n\n    render () {\n        return <>\n            <FormContext.Provider value={{ form: this as any }}>\n                <FormInspector form={this as Form} inspect={!!this.props.inspect}>\n                    <div onKeyDownCapture={this.handleSubmit}>\n                        {this.props.children}\n                        {this.renderFields()}\n                    </div>\n                </FormInspector>\n            </FormContext.Provider>\n        </>\n    }\n}\n\n\nForm.Submit = FormSubmit\nForm.State = FormState\nForm.Values = FormFieldsValues","import * as React from 'react'\nimport { FormContext } from './contexts/formContext';\n\nexport interface FormSubmitProps {\n    children?: (handleSubmit: () => void) => React.ReactNode\n}\n\nexport function FormSubmit(props: FormSubmitProps) {\n    return (\n        <FormContext.Consumer>\n            {(formContextValues) =>\n                <React.Fragment>\n                    {props.children && props.children(formContextValues.form!.submit)}\n                </React.Fragment>\n            }\n        </FormContext.Consumer>\n    )\n}\n","import * as React from 'react'\nimport { FormContext } from './contexts/formContext';\nimport * as Form from './form'\n\nexport interface FormStateProps<TData> {\n    children?: (state: Form.FormState<TData>) => React.ReactNode\n}\n\nexport function FormState<TData>(props: FormStateProps<TData>) {\n    return (\n        <FormContext.Consumer>\n            {(formContextValues) =>\n                <React.Fragment>\n                    {props.children && props.children(formContextValues.form!.state as Form.FormState<TData>)}\n                </React.Fragment>\n            }\n        </FormContext.Consumer>\n    )\n}\n","import * as React from 'react'\nimport { FormContext } from './contexts/formContext';\n\nexport interface FormFieldsValuesProps<TData> {\n    children?: (fieldsValues: TData) => React.ReactNode\n}\n\nexport function FormFieldsValues<TData>(props: FormFieldsValuesProps<TData>) {\n    return (\n        <FormContext.Consumer>\n            {(formContextValues) =>\n                <React.Fragment>\n                    {props.children && props.children(formContextValues.form!.fieldValues as TData)}\n                </React.Fragment>\n            }\n        </FormContext.Consumer>\n    )\n}","import React from \"react\";\nimport { FieldGroup } from \"../fieldGroup\";\nimport { Form } from \"../form\";\n\nexport interface FieldGroupContextValue {\n    form?: Form\n    fieldGroup?: FieldGroup\n    parentChain?: string[]\n}\n\nexport const FieldGroupContext = React.createContext<FieldGroupContextValue>({})","import { FieldValidator } from \"../interfaces/fieldValidator\";\nimport { CancelableValidator } from \"./cancelableValidation\";\n\n// Sync\nexport const requiredValidator: FieldValidator = (value: any) => {\n    return value ? undefined : 'Campo obrigatório...'\n}\n\n// Assync\nexport const delayedBobValidator: FieldValidator = (value: any) => {\n    return CancelableValidator((done, cancel) => {\n        const timerId = setTimeout(() => {\n            done(value === 'bob' ? undefined : `No Bob... was \"${value}\"`);\n         }, 2000);\n         \n         cancel(() => { clearTimeout(timerId) })\n    })\n}","import * as React from 'react'\nimport { ContextedField } from '../contextedField';\nimport { Inspector } from './inspector';\n\nexport interface IFieldInspector {\n    inspect: boolean\n    field: ContextedField\n    children?: any\n}\n\nexport function FieldInspector(props: IFieldInspector) {\n    return !props.inspect ?\n        props.children :\n        <Inspector \n            header={`Field ${props.field.fullName}`}\n            infos={JSON.stringify({useDebouce: props.field.props.fUseDebounce, ...props.field.getFieldStatus()}, null, 4)}\n            color={\"#dbf0fd\"}\n            boderColor={\"#7e56ff\"}\n        >\n            {props.children}\n        </Inspector>\n}","import * as React from 'react'\nimport { Form } from './form';\nimport { FieldBidings } from './interfaces/fieldBidings';\nimport { requiredValidator } from './validations/exampleValidators';\nimport { FieldValidator } from './interfaces/fieldValidator';\nimport { FieldInspector } from './inspectors/fieldInspector';\nimport * as Debounce from 'debounce'\nimport { FieldStatusWithErrorHint } from './interfaces/FieldStatusWithErrorHint';\n\nexport interface ContextedFieldProps {\n    // injected by the Field component\n    fForm?: Form \n    fFieldGroups?: string[]\n\n    // inform  by the user\n    fInnerFieldRef?: (ref: React.RefObject<any>) => void\n    fName: string\n\n    fCheckable?:boolean\n    fCheckedValue?: any\n\n    fRequired?: boolean\n    fExtraValidators?: FieldValidator[]\n    \n    fInspect?: boolean\n    fUseDebounce?: boolean\n    \n    fOnClick?: (value: any) => void\n    fOnBlur?: (value: any) => void\n    fOnFocus?: (value: any) => void\n    fOnChange?: (value: any) => void\n\n    children?: (bidings: FieldBidings, fieldStatusWithErrorHint: FieldStatusWithErrorHint) => React.ReactNode\n}\n\nexport interface ContextedFieldState {\n    value: any,\n    checked?: boolean\n}\n\nexport abstract class ContextedField extends React.Component<ContextedFieldProps, ContextedFieldState> {\n    private debouncedOnchange: any;\n    private innerFieldRef: React.RefObject<any>\n    private isDebouncing?: boolean\n    private lastValidators: FieldValidator[] = []\n\n    state: Readonly<ContextedFieldState> = {\n        value: ''\n    }\n\n    constructor(props: any) {\n        super(props)\n    \n        this.innerFieldRef = React.createRef();\n\n        if (this.props.fInnerFieldRef)\n            this.props.fInnerFieldRef(this.innerFieldRef)\n\n        this.onChange = this.onChange.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n\n        this.onChangeAfterDebouce = this.onChangeAfterDebouce.bind(this)\n        this.debouncedOnchange = Debounce.debounce(this.onChangeAfterDebouce, 200)\n\n        this.updateValidatorsOnFormIfNecessary();\n    }\n\n    /////////////////////////////////////////////////////////\n    // Validations\n\n    updateValidatorsOnFormIfNecessary() {\n        if (this.validatorsAreTheSameAsLastOnes()) \n            return\n        \n        this.lastValidators = this.getValidators();\n        this.props.fForm!.registerFieldValidators(this.fullName, this.lastValidators);\n    }\n    \n    getValidators() {\n        let validators:FieldValidator[] = []\n        \n        if(this.props.fRequired)\n            validators.push(requiredValidator)\n        if(this.props.fExtraValidators)\n            validators = [...validators, ...this.props.fExtraValidators]\n        \n        return validators;\n    }\n\n    validatorsAreTheSameAsLastOnes() {\n        const presentValidators = this.getValidators();\n        \n        if(this.lastValidators.length !== presentValidators.length) \n            return false\n\n        const validatorsCompared = this.lastValidators.filter((validator) => {\n            return presentValidators.find((presentValidator) => {\n                return presentValidator === validator\n            })\n        })\n\n        return validatorsCompared.length === this.lastValidators.length\n    }\n    \n    /////////////////////////////////////////////////////////\n    // Info Getters\n\n    get fullName() {\n        const fieldGroups = this.props.fFieldGroups || [] \n        return [...fieldGroups, this.props.fName].join('.');\n    }\n\n    getFieldStatus() {\n        return { \n            fullname: this.fullName,\n            ...this.props.fForm!.getFieldStatus(this.fullName) \n        } \n    }\n\n    /////////////////////////////////////////////////////////\n    // Proxy Events\n\n    onFocus(evt: any) {\n        if (this.props.fOnFocus)\n            this.props.fOnFocus(evt);\n    }\n    \n    onBlur(evt: any) {\n        this.props.fForm!.setFieldTouched(this.fullName)\n        \n        if (this.props.fOnBlur)\n            this.props.fOnBlur(evt);\n\n        const fieldData = this.getFieldStatus()\n        \n        if (!fieldData.hasValidated)\n            this.props.fForm!.validateField(this.fullName);\n    }\n\n    onClick(evt: any) {\n        if (this.props.fOnClick)\n            this.props.fOnClick(evt);\n    }\n\n    /**\n     * This method envolves events. Particulary html events\n     * @param evt \n     */\n    async onChange(evt: React.ChangeEvent<any>) {\n        let value;\n        \n        if (this.props.fCheckable) {\n            const isChecked = evt && evt.target && evt.target.checked\n            value = isChecked ? this.props.fCheckedValue : ''\n        } else {\n            value = evt && evt.target ? evt.target.value : evt\n        }\n\n        this.setFieldValue(value, () => {\n            if (evt.persist)\n                evt.persist();\n\n            if (this.props.fOnChange)\n                this.props.fOnChange(evt);\n        });\n    }\n\n    setFieldValue(value:any, cb: () => void) {\n        this.setState(() => ({ value }))\n        if (this.props.fUseDebounce === false) {\n           this.onChangeAfterDebouce(value, cb)\n        } else {\n            this.isDebouncing = true\n            this.debouncedOnchange(value, cb)\n        }\n    }\n\n    /**\n     * Flag the event as persisted, to prevent react egine\n     * to discart it.\n     * @param evt \n     */\n    persistEvent(evt: any) {\n        evt.persist();\n    }\n\n    async onChangeAfterDebouce(value: any, cb: () => void) {\n        this.isDebouncing = false\n        await this.props.fForm!.setFieldValue(this.fullName, value)\n        cb();\n    }\n\n    verifyIfFieldValueCorrespondsToFormsValue() {\n        const valueOnFormState = this.props.fForm!.getFieldValue(this.fullName);\n        if (!this.isDebouncing && valueOnFormState && (valueOnFormState !== this.state.value))\n            this.setState({ value: valueOnFormState })\n    }\n\n    /////////////////////////////////////////////////////////\n    // Render Cycle\n\n    componentDidMount() {\n        this.props.fForm!.registerField(this.fullName);\n        this.verifyIfFieldValueCorrespondsToFormsValue();\n        if (this.props.fCheckable && this.props.fCheckedValue === undefined)\n            console.warn(`Field \"${this.fullName}\" has marked as checkable, but hasn't any fCheckedValue...`);\n    }\n\n    componentDidUpdate() {\n        this.verifyIfFieldValueCorrespondsToFormsValue()\n        this.updateValidatorsOnFormIfNecessary()\n    }\n\n    componentWillUnmount() {\n        this.props.fForm!.unregisterField(this.fullName);\n    }\n    \n    /////////////////////////////////////////////////////////\n    // Rendering\n\n    render() {\n        const fieldStatus = this.getFieldStatus()\n        const fieldStatusWithErrorHint:FieldStatusWithErrorHint = { \n            ...fieldStatus,\n            shouldDisplayErrors: !!((fieldStatus.hasValidated || fieldStatus.touched || fieldStatus.dirty) && fieldStatus.errors && fieldStatus.errors.length)\n        }\n\n        let fieldBidings: FieldBidings = {\n            ref: this.innerFieldRef,\n            value: this.state.value,\n            onChange: this.onChange,\n            onClick: this.onClick,\n            onBlur: this.onBlur,\n            onFocus: this.onFocus,\n        }\n\n        if (this.props.fCheckable && this.state.value !== undefined)\n            fieldBidings = { ...fieldBidings, checked: this.state.value === this.props.fCheckedValue}\n\n        return <FieldInspector field={this} inspect={!!this.props.fInspect}>\n                {this.props.children && this.props.children(fieldBidings, fieldStatusWithErrorHint)}\n            </FieldInspector>\n    }\n}","import * as React from 'react'\nimport { FormContext } from './contexts/formContext';\nimport { FieldGroupContext } from './contexts/fieldGroupContext';\nimport { ContextedField, ContextedFieldProps } from './contextedField';\nimport { FieldBidings } from './interfaces/fieldBidings';\nimport { FieldStatusWithErrorHint } from './interfaces/FieldStatusWithErrorHint';\n\nexport interface FieldProps extends ContextedFieldProps { \n    children?: any\n}\n\nexport const Field = React.forwardRef<ContextedField, ContextedFieldProps>((props, ref) =>\n    <FormContext.Consumer>\n        {(formContextValues) =>\n            <FieldGroupContext.Consumer>\n                {(fieldGruopContextValues) =>\n                    <ContextedField\n                        ref={ref}\n                        fForm={formContextValues.form}\n                        fFieldGroups={fieldGruopContextValues.parentChain}\n                        {...props}\n                    />\n                }\n            </FieldGroupContext.Consumer>\n        }\n    </FormContext.Consumer>\n)\n\n/**\n * Returns a new object with ONLY fProps\n * @param args object\n */\nexport function fProps(...args: {[key: string]: any}[]) {\n    const allParams = Object.assign({}, ...args)\n    let newArgs: any = {}\n    for (const key in allParams) {\n        if (/f[A-Z]/g.test(key)) {\n            newArgs[key] = allParams[key];\n        }\n    }\n\n    return newArgs;\n}\n\n/**\n * Returns a new object with EXCEPT fProps\n * @param args object\n */\nexport function notFProps(...args: {[key: string]: any}[]) {\n     const allParams = Object.assign({}, ...args)\n     let newArgs: any = {}\n     for (const key in allParams) {\n        if (!/f[A-Z]/g.test(key)) {\n            newArgs[key] = allParams[key];\n        }\n    }\n    return newArgs;\n}\n\nexport interface FieldFactoryArgs<TProps, TExtraFProps = {}> {\n    (fprops: FieldProps & TExtraFProps, props: TProps, bidings: FieldBidings, fieldStatus: FieldStatusWithErrorHint): React.ReactNode\n}\n\nexport function FieldFactory<TProps, TExtraFProps = {}>(field: FieldFactoryArgs<TProps, TExtraFProps>, presetFProps?: Partial<FieldProps>) {\n    return (props: FieldProps & TExtraFProps & TProps) => \n        <Field {...fProps(props)} {...presetFProps}>\n            {(bidings, status) => field(fProps(props), notFProps(props), bidings, status)}\n        </Field>\n}","import React from \"react\";\nimport { FormContext } from \"./contexts/formContext\";\nimport { FieldGroupContext, FieldGroupContextValue } from \"./contexts/fieldGroupContext\";\nimport { Form } from \".\";\n\nexport interface FieldGroupProps {\n    name: string\n    children?: any\n}\n\nexport class FieldGroup extends React.Component<FieldGroupProps> {\n    \n    constructor(props: any) {\n        super(props)\n        this.getFieldGroupContextValue = this.getFieldGroupContextValue.bind(this);\n    }\n    \n    getFieldGroupContextValue(form: Form, parentFieldGroup: FieldGroupContextValue): FieldGroupContextValue {\n        let fieldGroups:string[] = [];\n        \n        if (parentFieldGroup.form === form)\n            fieldGroups = parentFieldGroup.parentChain || [];\n        \n        return {\n            form,\n            fieldGroup: this,\n            parentChain: [...fieldGroups, this.props.name]  \n        }\n    }\n\n    render() {\n        return <>\n        <FormContext.Consumer>\n            {(formContext) => \n                <FieldGroupContext.Consumer>\n                    {(parentFieldGroupContext) =>\n                        <FieldGroupContext.Provider value={this.getFieldGroupContextValue(formContext.form!, parentFieldGroupContext)}>\n                            {this.props.children}\n                        </FieldGroupContext.Provider>\n                    }\n                </FieldGroupContext.Consumer>\n            }\n        </FormContext.Consumer>\n        </>        \n    }\n}","import * as React from 'react'\nimport { FieldFactory } from '../react-satisfying-forms/field';\n\nexport const InputField = FieldFactory<React.InputHTMLAttributes<HTMLInputElement>>((fprops, props, fieldBindings, fielStatus) => \n    <input {...props} {...fieldBindings} />\n)","import * as React from 'react'\nimport { Form, FieldGroup } from '../react-satisfying-forms';\nimport { InputField } from '../rsf-default-fields/inputField';\n\nexport function SetFieldValues() {\n    const formRef = React.useRef<Form>(null);\n    \n    function handleClick() {\n        if (formRef.current)\n            formRef.current.setFieldValue('group', {\n                subitem: 'value',\n                subitem2: 'value2',\n            })\n    }\n\n    function onMount() {\n        if (formRef.current)\n            formRef.current.setFieldsValues({\n                test: 'test value',\n                group: null\n            })\n    }\n\n    React.useEffect(() => { onMount() }, []);\n\n    return (\n        <Form ref={formRef} inspect>\n            <InputField fName={'test'}/>\n            <FieldGroup name={'group'}>\n                <InputField fName={'subitem'}/>\n            </FieldGroup>\n            <button onClick={handleClick}>Set values</button>\n        </Form>\n    )\n}","import React, { Component } from 'react';\nimport { SetFieldValues } from './samples/setFieldValues';\n\nclass App extends Component {\n  render() {\n    return (\n        <SetFieldValues />\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}